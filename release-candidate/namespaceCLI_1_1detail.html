<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Radium Engine: CLI::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="radium-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radium Engine
   &#160;<span id="projectnumber">1.2.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceCLI_1_1detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CLI::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1AppFriend.html">AppFriend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is simply to allow tests access to <a class="el" href="classCLI_1_1App.html" title="Creates a command line program, with very few defaults.">App</a>'s protected functions.  <a href="structCLI_1_1detail_1_1AppFriend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1element__type.html">element_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">not a pointer  <a href="structCLI_1_1detail_1_1element__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1element__type_3_01T_00_01typename_01std_1_1enable__if_3_01is__copyable__p095259d742d782941ef6a8bf79b7548e.html">element_type&lt; T, typename std::enable_if&lt; is_copyable_ptr&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1element__value__type.html">element_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1ExistingDirectoryValidator.html">ExistingDirectoryValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing directory (returns error message if check fails)  <a href="classCLI_1_1detail_1_1ExistingDirectoryValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1ExistingFileValidator.html">ExistingFileValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing file (returns error message if check fails)  <a href="classCLI_1_1detail_1_1ExistingFileValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1ExistingPathValidator.html">ExistingPathValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an existing path.  <a href="classCLI_1_1detail_1_1ExistingPathValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1has__find.html">has_find</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1IPV4Validator.html">IPV4Validator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the given string is a legal ipv4 address.  <a href="classCLI_1_1detail_1_1IPV4Validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for complex.  <a href="classCLI_1_1detail_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__istreamable.html">is_istreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for input streamability.  <a href="classCLI_1_1detail_1_1is__istreamable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__mutable__container_3_01T_00_01conditional__t_3_01false_00_01void__t_34f912c4cf53fe26abfba2fd2b47c408d.html">is_mutable_container&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type, decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().clear()), decltype(std::declval&lt; T &gt;().insert(std::declval&lt; decltype(std::declval&lt; T &gt;().end())&gt;(), std::declval&lt; const typename T::value_type &amp; &gt;()))&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__ostreamable.html">is_ostreamable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__readable__container.html">is_readable_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__readable__container_3_01T_00_01conditional__t_3_01false_00_01void__t_a11f17935a0aadb8dce82cbccb9f2c68.html">is_readable_container&lt; T, conditional_t&lt; false, void_t&lt; decltype(std::declval&lt; T &gt;().end()), decltype(std::declval&lt; T &gt;().begin())&gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1is__wrapper_3_01T_00_01conditional__t_3_01false_00_01void__t_3_01typename64a0c6feb904f77c98810c843e4d2f1f.html">is_wrapper&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCLI_1_1detail_1_1NonexistentPathValidator.html">NonexistentPathValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for an non-existing path.  <a href="classCLI_1_1detail_1_1NonexistentPathValidator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1pair__adaptor.html">pair_adaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1pair__adaptor_3_01T_00_01conditional__t_3_01false_00_01void__t_3_01typenac7f3d35561ff46242630d08443185a90.html">pair_adaptor&lt; T, conditional_t&lt; false, void_t&lt; typename T::value_type::first_type, typename T::value_type::second_type &gt;, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1subtype__count.html">subtype_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of overloads to get the type size of an object.  <a href="structCLI_1_1detail_1_1subtype__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html">subtype_count_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declare the <a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html" title="forward declare the subtype_count_min structure">subtype_count_min</a> structure  <a href="structCLI_1_1detail_1_1subtype__count__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="structCLI_1_1detail_1_1type__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__complex_3_01Tcc27862bfce937e7a184d4899b689962.html">type_count&lt; T, typename std::enable_if&lt; is_complex&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for complex since it sometimes looks like a wrapper.  <a href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__complex_3_01Tcc27862bfce937e7a184d4899b689962.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutable__contb2a5be46bc2085412bb046a9416235bc.html">type_count&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_01is__wrapper_3_01Tafeacc1b065a285344dc61402947bdc3.html">type_count&lt; T, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_01T_e23863d22d2e4c34f6869731ca2da588.html">type_count&lt; T, typename std::enable_if&lt;!is_wrapper&lt; T &gt;::value &amp;&amp;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_complex&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="structCLI_1_1detail_1_1type__count_3_01T_00_01typename_01std_1_1enable__if_3_9is__wrapper_3_01T_e23863d22d2e4c34f6869731ca2da588.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will only trigger for actual void type.  <a href="structCLI_1_1detail_1_1type__count__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutablea4c3104627fe84803e06115cc7149e3c.html">type_count_base&lt; T, typename std::enable_if&lt; is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type count base for containers is the <a class="el" href="structCLI_1_1detail_1_1type__count__base.html" title="This will only trigger for actual void type.">type_count_base</a> of the individual element.  <a href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__mutablea4c3104627fe84803e06115cc7149e3c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__tuple__95c1a0ec6f7c1496130700c874085e8b.html">type_count_base&lt; T, typename std::enable_if&lt; is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the base tuple size  <a href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_01is__tuple__95c1a0ec6f7c1496130700c874085e8b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_9is__tuple__l80d36c9114ac17288799bef466c7bc7c.html">type_count_base&lt; T, typename std::enable_if&lt;!is_tuple_like&lt; T &gt;::value &amp;&amp;!is_mutable_container&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="structCLI_1_1detail_1_1type__count__base_3_01T_00_01typename_01std_1_1enable__if_3_9is__tuple__l80d36c9114ac17288799bef466c7bc7c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1wrapped__type.html">wrapped_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template to get the underlying value type if it exists or use a default  <a href="structCLI_1_1detail_1_1wrapped__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLI_1_1detail_1_1wrapped__type_3_01T_00_01def_00_01typename_01std_1_1enable__if_3_01is__wr7fdd281434af22fc0a3e380b9a3bffc8.html">wrapped_type&lt; T, def, typename std::enable_if&lt; is_wrapper&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type size for regular object types that do not look like a tuple.  <a href="structCLI_1_1detail_1_1wrapped__type_3_01T_00_01def_00_01typename_01std_1_1enable__if_3_01is__wr7fdd281434af22fc0a3e380b9a3bffc8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aba10771e3ff645fe1305be4cae517573"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#aba10771e3ff645fe1305be4cae517573">Classifier</a> { <br />
&#160;&#160;<a class="el" href="namespaceCLI_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693">Classifier::NONE</a>, 
<a class="el" href="namespaceCLI_1_1detail.html#aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6">Classifier::POSITIONAL_MARK</a>, 
<a class="el" href="namespaceCLI_1_1detail.html#aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77">Classifier::SHORT</a>, 
<a class="el" href="namespaceCLI_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3">Classifier::LONG</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceCLI_1_1detail.html#aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda">Classifier::WINDOWS_STYLE</a>, 
<a class="el" href="namespaceCLI_1_1detail.html#aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7">Classifier::SUBCOMMAND</a>, 
<a class="el" href="namespaceCLI_1_1detail.html#aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00">Classifier::SUBCOMMAND_TERMINATOR</a>
<br />
 }</td></tr>
<tr class="separator:aba10771e3ff645fe1305be4cae517573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27dda5da343e609526e3dacf435b1c6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">enabler</a> </td></tr>
<tr class="memdesc:af27dda5da343e609526e3dacf435b1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple empty scoped class.  <a href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">More...</a><br /></td></tr>
<tr class="separator:af27dda5da343e609526e3dacf435b1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a9a67e5f06ba0dc3f2ded2fed16f55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">path_type</a> { <a class="el" href="namespaceCLI_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928">path_type::nonexistent</a>, 
<a class="el" href="namespaceCLI_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac">path_type::file</a>, 
<a class="el" href="namespaceCLI_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20">path_type::directory</a>
 }</td></tr>
<tr class="memdesc:a20a9a67e5f06ba0dc3f2ded2fed16f55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCLI.html">CLI</a> enumeration of different file types.  <a href="namespaceCLI_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">More...</a><br /></td></tr>
<tr class="separator:a20a9a67e5f06ba0dc3f2ded2fed16f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac73a25f982318a475fa067b6561c43f5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ac73a25f982318a475fa067b6561c43f5">convert_arg_for_ini</a> (const std::string &amp;arg)</td></tr>
<tr class="separator:ac73a25f982318a475fa067b6561c43f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42001edb494b249cbb3d10c74c60e404"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a42001edb494b249cbb3d10c74c60e404">ini_join</a> (const std::vector&lt; std::string &gt; &amp;args, <a class="el" href="classchar.html">char</a> sepChar=',', <a class="el" href="classchar.html">char</a> arrayStart='[', <a class="el" href="classchar.html">char</a> arrayEnd=']')</td></tr>
<tr class="memdesc:a42001edb494b249cbb3d10c74c60e404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comma separated join, adds quotes if needed.  <a href="namespaceCLI_1_1detail.html#a42001edb494b249cbb3d10c74c60e404">More...</a><br /></td></tr>
<tr class="separator:a42001edb494b249cbb3d10c74c60e404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bea5b6211d9e469f415d55cccd5c63"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a35bea5b6211d9e469f415d55cccd5c63">generate_parents</a> (const std::string &amp;section, std::string &amp;name)</td></tr>
<tr class="separator:a35bea5b6211d9e469f415d55cccd5c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e109bd9b97994ead2ca0173f56d617"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a65e109bd9b97994ead2ca0173f56d617">checkParentSegments</a> (std::vector&lt; <a class="el" href="structCLI_1_1ConfigItem.html">ConfigItem</a> &gt; &amp;output, const std::string &amp;currentSection)</td></tr>
<tr class="separator:a65e109bd9b97994ead2ca0173f56d617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6f215bcb727ff49f126ac3e1a13e40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a1e6f215bcb727ff49f126ac3e1a13e40">split_short</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;rest)</td></tr>
<tr class="separator:a1e6f215bcb727ff49f126ac3e1a13e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de15b0ba0d12c9170d15693477808ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a0de15b0ba0d12c9170d15693477808ed">split_long</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;value)</td></tr>
<tr class="separator:a0de15b0ba0d12c9170d15693477808ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbd2b5b93afe2f10427dd6e32639b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#aadbd2b5b93afe2f10427dd6e32639b0c">split_windows_style</a> (const std::string &amp;current, std::string &amp;name, std::string &amp;value)</td></tr>
<tr class="separator:aadbd2b5b93afe2f10427dd6e32639b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf817a10b92907070c02b752c37aa09d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#abf817a10b92907070c02b752c37aa09d">split_names</a> (std::string current)</td></tr>
<tr class="separator:abf817a10b92907070c02b752c37aa09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ea386ace9f320e1ba59d7eba49b7cf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a49ea386ace9f320e1ba59d7eba49b7cf">get_default_flag_values</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a49ea386ace9f320e1ba59d7eba49b7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract default flag values either {def} or starting with a !  <a href="namespaceCLI_1_1detail.html#a49ea386ace9f320e1ba59d7eba49b7cf">More...</a><br /></td></tr>
<tr class="separator:a49ea386ace9f320e1ba59d7eba49b7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ae97bbbd9e400bd94b316dd865cb66"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::string &gt;, std::vector&lt; std::string &gt;, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a23ae97bbbd9e400bd94b316dd865cb66">get_names</a> (const std::vector&lt; std::string &gt; &amp;input)</td></tr>
<tr class="memdesc:a23ae97bbbd9e400bd94b316dd865cb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of short names, one of long names, and a single name.  <a href="namespaceCLI_1_1detail.html#a23ae97bbbd9e400bd94b316dd865cb66">More...</a><br /></td></tr>
<tr class="separator:a23ae97bbbd9e400bd94b316dd865cb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e78d046d8a9c2d6f246bd1e36e57ec6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">split</a> (const std::string &amp;s, <a class="el" href="classchar.html">char</a> delim)</td></tr>
<tr class="memdesc:a9e78d046d8a9c2d6f246bd1e36e57ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string by a delim.  <a href="namespaceCLI_1_1detail.html#a9e78d046d8a9c2d6f246bd1e36e57ec6">More...</a><br /></td></tr>
<tr class="separator:a9e78d046d8a9c2d6f246bd1e36e57ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab351f13ec104e2cba19ec6baf4a552f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab351f13ec104e2cba19ec6baf4a552f6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ab351f13ec104e2cba19ec6baf4a552f6">join</a> (const T &amp;v, std::string delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:ab351f13ec104e2cba19ec6baf4a552f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to join a string.  <a href="namespaceCLI_1_1detail.html#ab351f13ec104e2cba19ec6baf4a552f6">More...</a><br /></td></tr>
<tr class="separator:ab351f13ec104e2cba19ec6baf4a552f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8597debec6c8bc164109538253ffc623"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Callable , typename  = typename std::enable_if&lt;!std::is_constructible&lt;std::string, Callable&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8597debec6c8bc164109538253ffc623"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a8597debec6c8bc164109538253ffc623">join</a> (const T &amp;v, Callable func, std::string delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:a8597debec6c8bc164109538253ffc623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to join a string from processed elements.  <a href="namespaceCLI_1_1detail.html#a8597debec6c8bc164109538253ffc623">More...</a><br /></td></tr>
<tr class="separator:a8597debec6c8bc164109538253ffc623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74b520ee1011d38fde77f907ddfea40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af74b520ee1011d38fde77f907ddfea40"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af74b520ee1011d38fde77f907ddfea40">rjoin</a> (const T &amp;v, std::string delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:af74b520ee1011d38fde77f907ddfea40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a string in reverse order.  <a href="namespaceCLI_1_1detail.html#af74b520ee1011d38fde77f907ddfea40">More...</a><br /></td></tr>
<tr class="separator:af74b520ee1011d38fde77f907ddfea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae078b951ab0e11b84dffe200d0049c"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#acae078b951ab0e11b84dffe200d0049c">ltrim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:acae078b951ab0e11b84dffe200d0049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from left of string.  <a href="namespaceCLI_1_1detail.html#acae078b951ab0e11b84dffe200d0049c">More...</a><br /></td></tr>
<tr class="separator:acae078b951ab0e11b84dffe200d0049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb44de7c57bbb1384f737dc2f04265b"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">ltrim</a> (std::string &amp;str, const std::string &amp;filter)</td></tr>
<tr class="memdesc:a2cb44de7c57bbb1384f737dc2f04265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim anything from left of string.  <a href="namespaceCLI_1_1detail.html#a2cb44de7c57bbb1384f737dc2f04265b">More...</a><br /></td></tr>
<tr class="separator:a2cb44de7c57bbb1384f737dc2f04265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9338ae7c45f34f8240a31325d8d71c"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#aed9338ae7c45f34f8240a31325d8d71c">rtrim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:aed9338ae7c45f34f8240a31325d8d71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from right of string.  <a href="namespaceCLI_1_1detail.html#aed9338ae7c45f34f8240a31325d8d71c">More...</a><br /></td></tr>
<tr class="separator:aed9338ae7c45f34f8240a31325d8d71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27306fb661edc7a7017a09a0e9ee7b18"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">rtrim</a> (std::string &amp;str, const std::string &amp;filter)</td></tr>
<tr class="memdesc:a27306fb661edc7a7017a09a0e9ee7b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim anything from right of string.  <a href="namespaceCLI_1_1detail.html#a27306fb661edc7a7017a09a0e9ee7b18">More...</a><br /></td></tr>
<tr class="separator:a27306fb661edc7a7017a09a0e9ee7b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad394fad44bd6c2a82604abba63224a92"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ad394fad44bd6c2a82604abba63224a92">trim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:ad394fad44bd6c2a82604abba63224a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from string.  <a href="namespaceCLI_1_1detail.html#ad394fad44bd6c2a82604abba63224a92">More...</a><br /></td></tr>
<tr class="separator:ad394fad44bd6c2a82604abba63224a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ffd53b391fe1eebc540f26c8825692"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">trim</a> (std::string &amp;str, const std::string filter)</td></tr>
<tr class="memdesc:a42ffd53b391fe1eebc540f26c8825692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim anything from string.  <a href="namespaceCLI_1_1detail.html#a42ffd53b391fe1eebc540f26c8825692">More...</a><br /></td></tr>
<tr class="separator:a42ffd53b391fe1eebc540f26c8825692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7b00a328b3b2da564794081646c251"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a5c7b00a328b3b2da564794081646c251">trim_copy</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a5c7b00a328b3b2da564794081646c251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of the string and then trim it.  <a href="namespaceCLI_1_1detail.html#a5c7b00a328b3b2da564794081646c251">More...</a><br /></td></tr>
<tr class="separator:a5c7b00a328b3b2da564794081646c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242fa1bec3353c591a730efc6307f3ea"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">remove_quotes</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a242fa1bec3353c591a730efc6307f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove quotes at the front and back of a string either '"' or '\''  <a href="namespaceCLI_1_1detail.html#a242fa1bec3353c591a730efc6307f3ea">More...</a><br /></td></tr>
<tr class="separator:a242fa1bec3353c591a730efc6307f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bd3735d1104a453e5376a43140d5a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a09bd3735d1104a453e5376a43140d5a8">trim_copy</a> (const std::string &amp;str, const std::string &amp;filter)</td></tr>
<tr class="separator:a09bd3735d1104a453e5376a43140d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569874f0c04636b7f0e63f40caf6e170"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a569874f0c04636b7f0e63f40caf6e170">format_help</a> (std::ostream &amp;out, std::string name, const std::string &amp;description, std::size_t wid)</td></tr>
<tr class="memdesc:a569874f0c04636b7f0e63f40caf6e170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a two part "help" string.  <a href="namespaceCLI_1_1detail.html#a569874f0c04636b7f0e63f40caf6e170">More...</a><br /></td></tr>
<tr class="separator:a569874f0c04636b7f0e63f40caf6e170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af375283ee4242348cd6d3df419d7bc62"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af375283ee4242348cd6d3df419d7bc62">format_aliases</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;aliases, std::size_t wid)</td></tr>
<tr class="memdesc:af375283ee4242348cd6d3df419d7bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print subcommand aliases.  <a href="namespaceCLI_1_1detail.html#af375283ee4242348cd6d3df419d7bc62">More...</a><br /></td></tr>
<tr class="separator:af375283ee4242348cd6d3df419d7bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a05d1129df69e88135e178137b1fd89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a05d1129df69e88135e178137b1fd89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">valid_first_char</a> (T c)</td></tr>
<tr class="memdesc:a3a05d1129df69e88135e178137b1fd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the first character of an option.  <a href="namespaceCLI_1_1detail.html#a3a05d1129df69e88135e178137b1fd89">More...</a><br /></td></tr>
<tr class="separator:a3a05d1129df69e88135e178137b1fd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841371d5dbb0a52f453de4cc1d00cc51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a841371d5dbb0a52f453de4cc1d00cc51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">valid_later_char</a> (T c)</td></tr>
<tr class="memdesc:a841371d5dbb0a52f453de4cc1d00cc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify following characters of an option.  <a href="namespaceCLI_1_1detail.html#a841371d5dbb0a52f453de4cc1d00cc51">More...</a><br /></td></tr>
<tr class="separator:a841371d5dbb0a52f453de4cc1d00cc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274628d24f9e3fbc719284f1db263b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">valid_name_string</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a4274628d24f9e3fbc719284f1db263b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify an option name.  <a href="namespaceCLI_1_1detail.html#a4274628d24f9e3fbc719284f1db263b8">More...</a><br /></td></tr>
<tr class="separator:a4274628d24f9e3fbc719284f1db263b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b46b96102830769cc02952392e782f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a53b46b96102830769cc02952392e782f">is_separator</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a53b46b96102830769cc02952392e782f"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a string is a container segment separator (empty or "%%")  <a href="namespaceCLI_1_1detail.html#a53b46b96102830769cc02952392e782f">More...</a><br /></td></tr>
<tr class="separator:a53b46b96102830769cc02952392e782f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89ce22647a9f697b800d9c47b9d956f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ac89ce22647a9f697b800d9c47b9d956f">isalpha</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ac89ce22647a9f697b800d9c47b9d956f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that str consists of letters only.  <a href="namespaceCLI_1_1detail.html#ac89ce22647a9f697b800d9c47b9d956f">More...</a><br /></td></tr>
<tr class="separator:ac89ce22647a9f697b800d9c47b9d956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83709ec148057ec53df4383645727e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ae83709ec148057ec53df4383645727e9">to_lower</a> (std::string str)</td></tr>
<tr class="memdesc:ae83709ec148057ec53df4383645727e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a lower case version of a string.  <a href="namespaceCLI_1_1detail.html#ae83709ec148057ec53df4383645727e9">More...</a><br /></td></tr>
<tr class="separator:ae83709ec148057ec53df4383645727e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5359a7a0e33366a12e15523b100f591a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">remove_underscore</a> (std::string str)</td></tr>
<tr class="memdesc:a5359a7a0e33366a12e15523b100f591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove underscores from a string  <a href="namespaceCLI_1_1detail.html#a5359a7a0e33366a12e15523b100f591a">More...</a><br /></td></tr>
<tr class="separator:a5359a7a0e33366a12e15523b100f591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39b1977d7375250cc57d90723cf1554"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">find_and_replace</a> (std::string str, std::string from, std::string to)</td></tr>
<tr class="memdesc:ab39b1977d7375250cc57d90723cf1554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and replace a substring with another substring.  <a href="namespaceCLI_1_1detail.html#ab39b1977d7375250cc57d90723cf1554">More...</a><br /></td></tr>
<tr class="separator:ab39b1977d7375250cc57d90723cf1554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89da9fa11d234a8bf504d6ec85133cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ae89da9fa11d234a8bf504d6ec85133cc">has_default_flag_values</a> (const std::string &amp;flags)</td></tr>
<tr class="memdesc:ae89da9fa11d234a8bf504d6ec85133cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the flag definitions has possible false flags  <a href="namespaceCLI_1_1detail.html#ae89da9fa11d234a8bf504d6ec85133cc">More...</a><br /></td></tr>
<tr class="separator:ae89da9fa11d234a8bf504d6ec85133cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b9afbe8a438ab30291d35f1f24c87c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a73b9afbe8a438ab30291d35f1f24c87c">remove_default_flag_values</a> (std::string &amp;flags)</td></tr>
<tr class="separator:a73b9afbe8a438ab30291d35f1f24c87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356b9c9cc904af2b0a918fd55e86cd9c"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a356b9c9cc904af2b0a918fd55e86cd9c">find_member</a> (std::string name, const std::vector&lt; std::string &gt; names, <a class="el" href="classbool.html">bool</a> <a class="el" href="namespaceCLI.html#a0c52326d2681814c22aa1a93ce43375e">ignore_case</a>=false, <a class="el" href="classbool.html">bool</a> <a class="el" href="namespaceCLI.html#a111b6f05d21b9b84e7ba933ade79884c">ignore_underscore</a>=false)</td></tr>
<tr class="separator:a356b9c9cc904af2b0a918fd55e86cd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fbb1952b19838d8377ab714dc33e4c"><td class="memTemplParams" colspan="2">template&lt;typename Callable &gt; </td></tr>
<tr class="memitem:a59fbb1952b19838d8377ab714dc33e4c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a59fbb1952b19838d8377ab714dc33e4c">find_and_modify</a> (std::string str, std::string trigger, Callable modify)</td></tr>
<tr class="separator:a59fbb1952b19838d8377ab714dc33e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6e8a6354d9645d3da614f6734573a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#aad6e8a6354d9645d3da614f6734573a8">split_up</a> (std::string str, <a class="el" href="classchar.html">char</a> delimiter='\0')</td></tr>
<tr class="separator:aad6e8a6354d9645d3da614f6734573a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f983b056b683129ec20e53d8c6141ab"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a6f983b056b683129ec20e53d8c6141ab">fix_newlines</a> (const std::string &amp;leader, std::string input)</td></tr>
<tr class="separator:a6f983b056b683129ec20e53d8c6141ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24078bb1f5e51808a5001a47d2b40c3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ac24078bb1f5e51808a5001a47d2b40c3">escape_detect</a> (std::string &amp;str, std::size_t offset)</td></tr>
<tr class="separator:ac24078bb1f5e51808a5001a47d2b40c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af694bfd321727b1a8c5d7dab22d52617"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af694bfd321727b1a8c5d7dab22d52617">add_quotes_if_needed</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:af694bfd321727b1a8c5d7dab22d52617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add quotes if the string contains spaces.  <a href="namespaceCLI_1_1detail.html#af694bfd321727b1a8c5d7dab22d52617">More...</a><br /></td></tr>
<tr class="separator:af694bfd321727b1a8c5d7dab22d52617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; is_istreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a65d0ac7d1e313c85e8027b8e7a82d29a">from_stream</a> (const std::string &amp;istring, T &amp;obj)</td></tr>
<tr class="memdesc:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated operation to get a value from a stream.  <a href="namespaceCLI_1_1detail.html#a65d0ac7d1e313c85e8027b8e7a82d29a">More...</a><br /></td></tr>
<tr class="separator:a65d0ac7d1e313c85e8027b8e7a82d29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e94052d485636fc9f18c21009026577"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a0e94052d485636fc9f18c21009026577"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a> (T &amp;&amp;value) -&gt; decltype(std::forward&lt; T &gt;(value))</td></tr>
<tr class="memdesc:a0e94052d485636fc9f18c21009026577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (directly forward if this can become a string)  <a href="namespaceCLI_1_1detail.html#a0e94052d485636fc9f18c21009026577">More...</a><br /></td></tr>
<tr class="separator:a0e94052d485636fc9f18c21009026577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a4e5965e3013bad7369e985e2f2fd42f4">to_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4e5965e3013bad7369e985e2f2fd42f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from the object.  <a href="namespaceCLI_1_1detail.html#a4e5965e3013bad7369e985e2f2fd42f4">More...</a><br /></td></tr>
<tr class="separator:a4e5965e3013bad7369e985e2f2fd42f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c070858740ce15aaecb1c5f04e21a09"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;is_ostreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a9c070858740ce15aaecb1c5f04e21a09"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">to_string</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a9c070858740ce15aaecb1c5f04e21a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an object to a string (streaming must be supported for that type)  <a href="namespaceCLI_1_1detail.html#a9c070858740ce15aaecb1c5f04e21a09">More...</a><br /></td></tr>
<tr class="separator:a9c070858740ce15aaecb1c5f04e21a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcb244a7701fc68da3a863b58daf615"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt; std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a1bcb244a7701fc68da3a863b58daf615"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a1bcb244a7701fc68da3a863b58daf615">checked_to_string</a> (T &amp;&amp;value) -&gt; decltype(<a class="el" href="namespaceCLI_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(std::forward&lt; T &gt;(value)))</td></tr>
<tr class="memdesc:a1bcb244a7701fc68da3a863b58daf615"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <a href="namespaceCLI_1_1detail.html#a1bcb244a7701fc68da3a863b58daf615">More...</a><br /></td></tr>
<tr class="separator:a1bcb244a7701fc68da3a863b58daf615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae396058c9ea28259db0c05376bf9c1de"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt;!std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ae396058c9ea28259db0c05376bf9c1de"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ae396058c9ea28259db0c05376bf9c1de">checked_to_string</a> (T &amp;&amp;)</td></tr>
<tr class="memdesc:ae396058c9ea28259db0c05376bf9c1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">special template overload  <a href="namespaceCLI_1_1detail.html#ae396058c9ea28259db0c05376bf9c1de">More...</a><br /></td></tr>
<tr class="separator:ae396058c9ea28259db0c05376bf9c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a9a74f119a795b25c40db74ffa21d3c2d">value_string</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a9a74f119a795b25c40db74ffa21d3c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a string as a convertible value for arithmetic types  <a href="namespaceCLI_1_1detail.html#a9a74f119a795b25c40db74ffa21d3c2d">More...</a><br /></td></tr>
<tr class="separator:a9a74f119a795b25c40db74ffa21d3c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130e048f492ea4619246e2f4cabaf4ac"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a130e048f492ea4619246e2f4cabaf4ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a130e048f492ea4619246e2f4cabaf4ac">value_string</a> (const T &amp;value) -&gt; decltype(<a class="el" href="namespaceCLI_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>(value))</td></tr>
<tr class="memdesc:a130e048f492ea4619246e2f4cabaf4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">for other types just use the regular to_string function  <a href="namespaceCLI_1_1detail.html#a130e048f492ea4619246e2f4cabaf4ac">More...</a><br /></td></tr>
<tr class="separator:a130e048f492ea4619246e2f4cabaf4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af643ce5d039d1c94f85ca05591501085"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:af643ce5d039d1c94f85ca05591501085"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I==<a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, <a class="el" href="classint.html">int</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a> ()</td></tr>
<tr class="memdesc:af643ce5d039d1c94f85ca05591501085"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 if the index &gt; tuple size  <a href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">More...</a><br /></td></tr>
<tr class="separator:af643ce5d039d1c94f85ca05591501085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722986055318f9f83c37749ff14c652f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t I&gt; </td></tr>
<tr class="memitem:a722986055318f9f83c37749ff14c652f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; I&lt; <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, <a class="el" href="classint.html">int</a> &gt;::type <a class="el" href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>() { return <a class="el" href="structCLI_1_1detail_1_1subtype__count.html">subtype_count</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+<a class="el" href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt; T, I+1 &gt;);}template&lt; typename T &gt;struct <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T, typename std::enable_if&lt; <a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt; T, 0 &gt;) };};template&lt; typename T &gt;struct <a class="el" href="structCLI_1_1detail_1_1subtype__count.html">subtype_count</a> { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ? <a class="el" href="namespaceCLI_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> :<a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value };};template&lt; typename T, typename Enable=void &gt;struct type_count_min { static const <a class="el" href="classint.html">int</a> value { 0 };};template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt;!<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value };};template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { 1 };};template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename T::value_type &gt;::value };};template&lt; typename T, std::size_t I &gt;constexpr typename std::enable_if&lt; I==<a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, <a class="el" href="classint.html">int</a> &gt;::type tuple_type_size_min() { return 0;}template&lt; typename T, std::size_t I &gt; constexpr typename std::enable_if&lt; I&lt; <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, <a class="el" href="classint.html">int</a> &gt;::type tuple_type_size_min() { return <a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::value+tuple_type_size_min&lt; T, I+1 &gt;);}template&lt; typename T &gt;struct type_count_min&lt; T, typename std::enable_if&lt; <a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { tuple_type_size_min&lt; T, 0 &gt;) };};template&lt; typename T &gt;struct <a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html">subtype_count_min</a> { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value ?((<a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value&lt; <a class="el" href="namespaceCLI_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a>) ? <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value :0) :type_count_min&lt; T &gt;::value };};template&lt; typename T, typename Enable=void &gt;struct expected_count { static const <a class="el" href="classint.html">int</a> value { 0 };};template&lt; typename T &gt;struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!std::is_void&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { 1 };};template&lt; typename T &gt;struct expected_count&lt; T, typename std::enable_if&lt; <a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="namespaceCLI_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> };};template&lt; typename T &gt;struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr <a class="el" href="classint.html">int</a> value { expected_count&lt; typename T::value_type &gt;::value };};enum class object_category :<a class="el" href="classint.html">int</a> { char_value=1, integral_value=2, unsigned_integral=4, enumeration=6, boolean_value=8, floating_point=10, number_constructible=12, double_constructible=14, integer_constructible=16, string_assignable=23, string_constructible=24, other=45, wrapper_value=50, complex_number=60, tuple_value=70, container_value=80,};template&lt; typename T, typename Enable=void &gt;struct classify_object { static constexpr object_category value { object_category::other };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, <a class="el" href="classchar.html">char</a> &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &amp;&amp;!<a class="el" href="structCLI_1_1is__bool.html">is_bool</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::integral_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, <a class="el" href="classchar.html">char</a> &gt;::value &amp;&amp;!<a class="el" href="structCLI_1_1is__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::unsigned_integral };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classchar.html">char</a> &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::char_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="structCLI_1_1is__bool.html">is_bool</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::boolean_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::floating_point };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;std::is_assignable&lt; T &amp;, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::string_assignable };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;(<a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1) &amp;&amp;std::is_constructible&lt; T, std::string &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::string_constructible };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; std::is_enum&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::enumeration };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::complex_number };};template&lt; typename T &gt;struct uncommon_type { using type=typename std::conditional&lt; !std::is_floating_point&lt; T &gt;::value &amp;&amp;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_assignable&lt; T &amp;, std::string &gt;::value &amp;&amp;!std::is_constructible&lt; T, std::string &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, std::true_type, std::false_type &gt;::type;static constexpr <a class="el" href="classbool.html">bool</a> value=type::value;};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt;(!<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;uncommon_type&lt; T &gt;::value)&gt;::type &gt; { static constexpr object_category value { object_category::wrapper_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, <a class="el" href="classint.html">int</a> &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::number_constructible };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, <a class="el" href="classint.html">int</a> &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::integer_constructible };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; uncommon_type&lt; T &gt;::value &amp;&amp;<a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value==1 &amp;&amp;!<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, <a class="el" href="classint.html">int</a> &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::double_constructible };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt; T &gt;::value &amp;&amp;((<a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt; T &gt;::value &gt;=2 &amp;&amp;!<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt; T &gt;::value)||(uncommon_type&lt; T &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;!<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt; T, <a class="el" href="classint.html">int</a> &gt;::value))&gt;::type &gt; { static constexpr object_category value { object_category::tuple_value };};template&lt; typename T &gt;struct classify_object&lt; T, typename std::enable_if&lt; <a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt; T &gt;::value &gt;::type &gt; { static constexpr object_category value { object_category::container_value };};template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::char_value, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;CHAR&quot;;}template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::integer_constructible, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;INT&quot;;}template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::unsigned_integral, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;UINT&quot;;}template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::floating_point||classify_object&lt; T &gt;::value==object_category::number_constructible||classify_object&lt; T &gt;::value==object_category::double_constructible, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;FLOAT&quot;;}template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::enumeration, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;ENUM&quot;;}template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::boolean_value, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;BOOLEAN&quot;;}template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::complex_number, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;COMPLEX&quot;;}template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value &gt;=object_category::string_assignable &amp;&amp;classify_object&lt; T &gt;::value&lt;=object_category::other, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;constexpr const <a class="el" href="classchar.html">char</a> *type_name() { return &quot;TEXT&quot;;}template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;std::string type_name();template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;std::string type_name();template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value==1, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt;=<a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a> &gt;inline std::string type_name() { return type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; 0, T &gt;::type &gt;::type &gt;);}template&lt; typename T, std::size_t I &gt;inline typename std::enable_if&lt; I==<a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value, std::string &gt;::type tuple_name() { return std::string {};}template&lt; typename T, std::size_t I &gt;inline typename std::enable_if&lt;(I&lt; <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value), std::string &gt;::type tuple_name() { std::string str=std::string(type_name&lt; typename std::decay&lt; typename std::tuple_element&lt; I, T &gt;::type &gt;::type &gt;))+','+tuple_name&lt; T, I+1 &gt;);if(str.back()==',') str.pop_back();return str;}template&lt; typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt; classify_object&lt; T &gt;::value==object_category::tuple_value &amp;&amp;<a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt; T &gt;::value &gt;=2, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a> &gt; &gt; std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a722986055318f9f83c37749ff14c652f">type_name</a> ()</td></tr>
<tr class="memdesc:a722986055318f9f83c37749ff14c652f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively generate the tuple type name.  <a href="namespaceCLI_1_1detail.html#a722986055318f9f83c37749ff14c652f">More...</a><br /></td></tr>
<tr class="separator:a722986055318f9f83c37749ff14c652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397d777acde370a61fdfc1022a97508b"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt; &gt; </td></tr>
<tr class="memitem:a397d777acde370a61fdfc1022a97508b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a397d777acde370a61fdfc1022a97508b">type_name</a> ()</td></tr>
<tr class="memdesc:a397d777acde370a61fdfc1022a97508b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type name for a type that has a value_type member  <a href="namespaceCLI_1_1detail.html#a397d777acde370a61fdfc1022a97508b">More...</a><br /></td></tr>
<tr class="separator:a397d777acde370a61fdfc1022a97508b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6685ecdb07b40a316035bb4af9b02e6"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af6685ecdb07b40a316035bb4af9b02e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">integral_conversion</a> (const std::string &amp;input, T &amp;output) noexcept</td></tr>
<tr class="memdesc:af6685ecdb07b40a316035bb4af9b02e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an unsigned integral.  <a href="namespaceCLI_1_1detail.html#af6685ecdb07b40a316035bb4af9b02e6">More...</a><br /></td></tr>
<tr class="separator:af6685ecdb07b40a316035bb4af9b02e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45abf683b881127298aa28b3c4e6cf5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af45abf683b881127298aa28b3c4e6cf5">to_flag_value</a> (std::string val)</td></tr>
<tr class="memdesc:af45abf683b881127298aa28b3c4e6cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a flag into an integer value typically binary flags.  <a href="namespaceCLI_1_1detail.html#af45abf683b881127298aa28b3c4e6cf5">More...</a><br /></td></tr>
<tr class="separator:af45abf683b881127298aa28b3c4e6cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af286727de86fce444325681379e2c511"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:af286727de86fce444325681379e2c511"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#af286727de86fce444325681379e2c511">lexical_cast</a> (const std::string &amp;input, T &amp;output)</td></tr>
<tr class="memdesc:af286727de86fce444325681379e2c511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer conversion.  <a href="namespaceCLI_1_1detail.html#af286727de86fce444325681379e2c511">More...</a><br /></td></tr>
<tr class="separator:af286727de86fce444325681379e2c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6647281bf64bba7b07737297ae1895d"><td class="memTemplParams" colspan="2">template&lt;typename AssignTo , typename ConvertTo , enable_if_t&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible), detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:ab6647281bf64bba7b07737297ae1895d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ab6647281bf64bba7b07737297ae1895d">lexical_assign</a> (const std::string &amp;input, AssignTo &amp;output)</td></tr>
<tr class="memdesc:ab6647281bf64bba7b07737297ae1895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value through lexical cast operations.  <a href="namespaceCLI_1_1detail.html#ab6647281bf64bba7b07737297ae1895d">More...</a><br /></td></tr>
<tr class="separator:ab6647281bf64bba7b07737297ae1895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197be0b62b4d4deef0f5cac600a6b759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCLI_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">path_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">check_path</a> (const <a class="el" href="classchar.html">char</a> *file) noexcept</td></tr>
<tr class="memdesc:a197be0b62b4d4deef0f5cac600a6b759"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type of the path from a file name  <a href="namespaceCLI_1_1detail.html#a197be0b62b4d4deef0f5cac600a6b759">More...</a><br /></td></tr>
<tr class="separator:a197be0b62b4d4deef0f5cac600a6b759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6cf48feae9d909d52e7b4c346cba29"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:a0c6cf48feae9d909d52e7b4c346cba29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">smart_deref</a> (T value) -&gt; decltype(*value)</td></tr>
<tr class="separator:a0c6cf48feae9d909d52e7b4c346cba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd67b783a1c4441c89f071774ac398b"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt;!is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:adcd67b783a1c4441c89f071774ac398b"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference&lt; T &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#adcd67b783a1c4441c89f071774ac398b">smart_deref</a> (T &amp;value)</td></tr>
<tr class="separator:adcd67b783a1c4441c89f071774ac398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f66945cfe53b556e4c311f9a88a155"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75f66945cfe53b556e4c311f9a88a155"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a75f66945cfe53b556e4c311f9a88a155">generate_set</a> (const T &amp;set)</td></tr>
<tr class="memdesc:a75f66945cfe53b556e4c311f9a88a155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string representation of a set.  <a href="namespaceCLI_1_1detail.html#a75f66945cfe53b556e4c311f9a88a155">More...</a><br /></td></tr>
<tr class="separator:a75f66945cfe53b556e4c311f9a88a155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320e031a5eb12297a140d2d6fc73362a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a320e031a5eb12297a140d2d6fc73362a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a320e031a5eb12297a140d2d6fc73362a">generate_map</a> (const T &amp;map, <a class="el" href="classbool.html">bool</a> key_only=false)</td></tr>
<tr class="memdesc:a320e031a5eb12297a140d2d6fc73362a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a string representation of a map.  <a href="namespaceCLI_1_1detail.html#a320e031a5eb12297a140d2d6fc73362a">More...</a><br /></td></tr>
<tr class="separator:a320e031a5eb12297a140d2d6fc73362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b4a0a97c9b07110595765887647385"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V , enable_if_t&lt;!has_find&lt; T, V &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </td></tr>
<tr class="memitem:aa4b4a0a97c9b07110595765887647385"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#aa4b4a0a97c9b07110595765887647385">search</a> (const T &amp;set, const <a class="el" href="classV.html">V</a> &amp;val) -&gt; std::pair&lt; <a class="el" href="classbool.html">bool</a>, decltype(std::begin(<a class="el" href="namespaceCLI_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt;</td></tr>
<tr class="memdesc:aa4b4a0a97c9b07110595765887647385"><td class="mdescLeft">&#160;</td><td class="mdescRight">A search function.  <a href="namespaceCLI_1_1detail.html#aa4b4a0a97c9b07110595765887647385">More...</a><br /></td></tr>
<tr class="separator:aa4b4a0a97c9b07110595765887647385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb81a667288aa66a4576a06b9322092"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:abcb81a667288aa66a4576a06b9322092"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#abcb81a667288aa66a4576a06b9322092">search</a> (const T &amp;set, const <a class="el" href="classV.html">V</a> &amp;val, const std::function&lt; <a class="el" href="classV.html">V</a>(<a class="el" href="classV.html">V</a>)&gt; &amp;filter_function) -&gt; std::pair&lt; <a class="el" href="classbool.html">bool</a>, decltype(std::begin(<a class="el" href="namespaceCLI_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>(set)))&gt;</td></tr>
<tr class="memdesc:abcb81a667288aa66a4576a06b9322092"><td class="mdescLeft">&#160;</td><td class="mdescRight">A search function with a filter function.  <a href="namespaceCLI_1_1detail.html#abcb81a667288aa66a4576a06b9322092">More...</a><br /></td></tr>
<tr class="separator:abcb81a667288aa66a4576a06b9322092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96583f0b43752f7fa77a6c24dae4802"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac96583f0b43752f7fa77a6c24dae4802"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_signed&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ac96583f0b43752f7fa77a6c24dae4802">overflowCheck</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ac96583f0b43752f7fa77a6c24dae4802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a check for overflow on signed numbers.  <a href="namespaceCLI_1_1detail.html#ac96583f0b43752f7fa77a6c24dae4802">More...</a><br /></td></tr>
<tr class="separator:ac96583f0b43752f7fa77a6c24dae4802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9da7d60b3b5738079257829c777c9c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9da7d60b3b5738079257829c777c9c7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_signed&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">overflowCheck</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ad9da7d60b3b5738079257829c777c9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a check for overflow on unsigned numbers.  <a href="namespaceCLI_1_1detail.html#ad9da7d60b3b5738079257829c777c9c7">More...</a><br /></td></tr>
<tr class="separator:ad9da7d60b3b5738079257829c777c9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, <a class="el" href="classbool.html">bool</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#ac1a57be7d4de9c0552f91b8f16d47aad">checked_multiply</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a *= b; if it doesn't cause integer overflow. Returns false otherwise.  <a href="namespaceCLI_1_1detail.html#ac1a57be7d4de9c0552f91b8f16d47aad">More...</a><br /></td></tr>
<tr class="separator:ac1a57be7d4de9c0552f91b8f16d47aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, <a class="el" href="classbool.html">bool</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#aaf8289908c3b0f3fa2cb597f787a06aa">checked_multiply</a> (T &amp;a, T b)</td></tr>
<tr class="memdesc:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a *= b; if it doesn't equal infinity. Returns false otherwise.  <a href="namespaceCLI_1_1detail.html#aaf8289908c3b0f3fa2cb597f787a06aa">More...</a><br /></td></tr>
<tr class="separator:aaf8289908c3b0f3fa2cb597f787a06aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c9893591d9e9d3d4c9d7282d50b9d2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a33c9893591d9e9d3d4c9d7282d50b9d2">split_program_name</a> (std::string commandline)</td></tr>
<tr class="separator:a33c9893591d9e9d3d4c9d7282d50b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a99abe3824b1f1bea457ad0ae635f5c51"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> { 1 &lt;&lt; 29 }</td></tr>
<tr class="separator:a99abe3824b1f1bea457ad0ae635f5c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c35a876e2917ffdc1ee618e0c06619"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">enabler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">dummy</a> = {}</td></tr>
<tr class="memdesc:a01c35a876e2917ffdc1ee618e0c06619"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance to use in EnableIf.  <a href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">More...</a><br /></td></tr>
<tr class="separator:a01c35a876e2917ffdc1ee618e0c06619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aba10771e3ff645fe1305be4cae517573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba10771e3ff645fe1305be4cae517573">&#9670;&nbsp;</a></span>Classifier</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceCLI_1_1detail.html#aba10771e3ff645fe1305be4cae517573">CLI::detail::Classifier</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573a2b1681c49e27b242d19b93c5c3620cb6"></a>POSITIONAL_MARK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573aa35c2b02966b1563e5bf7b81b8b0cf77"></a>SHORT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ac1fabfea54ec6011e694f211f3ffebf3"></a>LONG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573a0693f2b4d4f0740bc76a2d65566b4fda"></a>WINDOWS_STYLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ac4fb22412f02354dbe5574e37caf50a7"></a>SUBCOMMAND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aba10771e3ff645fe1305be4cae517573ab447b0bfeb6e4502fb6a0c4223fb8d00"></a>SUBCOMMAND_TERMINATOR&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="App_8hpp_source.html#l00048">48</a> of file <a class="el" href="App_8hpp_source.html">App.hpp</a>.</p>

</div>
</div>
<a id="af27dda5da343e609526e3dacf435b1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27dda5da343e609526e3dacf435b1c6">&#9670;&nbsp;</a></span>enabler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">CLI::detail::enabler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple empty scoped class. </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00030">30</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a20a9a67e5f06ba0dc3f2ded2fed16f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a9a67e5f06ba0dc3f2ded2fed16f55">&#9670;&nbsp;</a></span>path_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceCLI_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">CLI::detail::path_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceCLI.html">CLI</a> enumeration of different file types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a20a9a67e5f06ba0dc3f2ded2fed16f55a357f5c155c9da6842b84ad1066996928"></a>nonexistent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a20a9a67e5f06ba0dc3f2ded2fed16f55a8c7dd922ad47494fc02c388e12c00eac"></a>file&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a20a9a67e5f06ba0dc3f2ded2fed16f55a5f8f22b8cdbaeee8cf857673a9b6ba20"></a>directory&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00300">300</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af694bfd321727b1a8c5d7dab22d52617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af694bfd321727b1a8c5d7dab22d52617">&#9670;&nbsp;</a></span>add_quotes_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::add_quotes_if_needed </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add quotes if the string contains spaces. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00433">433</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a197be0b62b4d4deef0f5cac600a6b759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197be0b62b4d4deef0f5cac600a6b759">&#9670;&nbsp;</a></span>check_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCLI_1_1detail.html#a20a9a67e5f06ba0dc3f2ded2fed16f55">path_type</a> CLI::detail::check_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchar.html">char</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type of the path from a file name </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00327">327</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>

</div>
</div>
<a id="ac1a57be7d4de9c0552f91b8f16d47aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a57be7d4de9c0552f91b8f16d47aad">&#9670;&nbsp;</a></span>checked_multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;T&gt;::value, <a class="el" href="classbool.html">bool</a>&gt;::type CLI::detail::checked_multiply </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a *= b; if it doesn't cause integer overflow. Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00679">679</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_ac1a57be7d4de9c0552f91b8f16d47aad_cgraph.svg" width="398" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaf8289908c3b0f3fa2cb597f787a06aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8289908c3b0f3fa2cb597f787a06aa">&#9670;&nbsp;</a></span>checked_multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, <a class="el" href="classbool.html">bool</a>&gt;::type CLI::detail::checked_multiply </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a *= b; if it doesn't equal infinity. Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00694">694</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>

</div>
</div>
<a id="ae396058c9ea28259db0c05376bf9c1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae396058c9ea28259db0c05376bf9c1de">&#9670;&nbsp;</a></span>checked_to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt;!std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::checked_to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special template overload </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00400">400</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a1bcb244a7701fc68da3a863b58daf615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcb244a7701fc68da3a863b58daf615">&#9670;&nbsp;</a></span>checked_to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T , enable_if_t&lt; std::is_same&lt; T1, T2 &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::checked_to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceCLI_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>( std::forward&lt;T&gt;( value ) ) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>special template overload </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00391">391</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a1bcb244a7701fc68da3a863b58daf615_cgraph.svg" width="359" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a65e109bd9b97994ead2ca0173f56d617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e109bd9b97994ead2ca0173f56d617">&#9670;&nbsp;</a></span>checkParentSegments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLI::detail::checkParentSegments </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCLI_1_1ConfigItem.html">ConfigItem</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>currentSection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>assuming non default segments do a check on the close and open of the segments in a configItem structure </p>

<p class="definition">Definition at line <a class="el" href="Config_8hpp_source.html#l00112">112</a> of file <a class="el" href="Config_8hpp_source.html">Config.hpp</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a65e109bd9b97994ead2ca0173f56d617_cgraph.svg" width="586" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac73a25f982318a475fa067b6561c43f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73a25f982318a475fa067b6561c43f5">&#9670;&nbsp;</a></span>convert_arg_for_ini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::convert_arg_for_ini </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Config_8hpp_source.html#l00026">26</a> of file <a class="el" href="Config_8hpp_source.html">Config.hpp</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_ac73a25f982318a475fa067b6561c43f5_cgraph.svg" width="568" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac24078bb1f5e51808a5001a47d2b40c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24078bb1f5e51808a5001a47d2b40c3">&#9670;&nbsp;</a></span>escape_detect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CLI::detail::escape_detect </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function detects an equal or colon followed by an escaped quote after an argument then modifies the string to replace the equality with a space. This is needed to allow the split up function to work properly and is intended to be used with the find_and_modify function the return value is the offset+1 which is required by the find_and_modify function. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00420">420</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a59fbb1952b19838d8377ab714dc33e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fbb1952b19838d8377ab714dc33e4c">&#9670;&nbsp;</a></span>find_and_modify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::find_and_modify </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>modify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a trigger string and call a modify callable function that takes the current string and starting position of the trigger and returns the position in the string to search for the next trigger string </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00333">333</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="ab39b1977d7375250cc57d90723cf1554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39b1977d7375250cc57d90723cf1554">&#9670;&nbsp;</a></span>find_and_replace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::find_and_replace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and replace a substring with another substring. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00262">262</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a356b9c9cc904af2b0a918fd55e86cd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356b9c9cc904af2b0a918fd55e86cd9c">&#9670;&nbsp;</a></span>find_member()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t CLI::detail::find_member </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_case</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_underscore</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a string is a member of a list of strings and optionally ignore case or ignore underscores </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00294">294</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a356b9c9cc904af2b0a918fd55e86cd9c_cgraph.svg" width="610" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6f983b056b683129ec20e53d8c6141ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f983b056b683129ec20e53d8c6141ab">&#9670;&nbsp;</a></span>fix_newlines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::fix_newlines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>leader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a leader to the beginning of all new lines (nothing is added at the start of the first line). <code>"; "</code> would be for ini files</p>
<p>Can't use Regex, or this would be a subs. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00403">403</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="af375283ee4242348cd6d3df419d7bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af375283ee4242348cd6d3df419d7bc62">&#9670;&nbsp;</a></span>format_aliases()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; CLI::detail::format_aliases </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>aliases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>wid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print subcommand aliases. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00197">197</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a569874f0c04636b7f0e63f40caf6e170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569874f0c04636b7f0e63f40caf6e170">&#9670;&nbsp;</a></span>format_help()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; CLI::detail::format_help </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>wid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a two part "help" string. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00178">178</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a65d0ac7d1e313c85e8027b8e7a82d29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d0ac7d1e313c85e8027b8e7a82d29a">&#9670;&nbsp;</a></span>from_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; is_istreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::from_stream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>istring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated operation to get a value from a stream. </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00260">260</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a320e031a5eb12297a140d2d6fc73362a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320e031a5eb12297a140d2d6fc73362a">&#9670;&nbsp;</a></span>generate_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::generate_map </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>key_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string representation of a map. </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00578">578</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a320e031a5eb12297a140d2d6fc73362a_cgraph.svg" width="400" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a35bea5b6211d9e469f415d55cccd5c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bea5b6211d9e469f415d55cccd5c63">&#9670;&nbsp;</a></span>generate_parents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::generate_parents </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Config_8hpp_source.html#l00087">87</a> of file <a class="el" href="Config_8hpp_source.html">Config.hpp</a>.</p>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a35bea5b6211d9e469f415d55cccd5c63_cgraph.svg" width="363" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a75f66945cfe53b556e4c311f9a88a155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f66945cfe53b556e4c311f9a88a155">&#9670;&nbsp;</a></span>generate_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::generate_set </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a string representation of a set. </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00563">563</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a75f66945cfe53b556e4c311f9a88a155_cgraph.svg" width="416" height="170"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a49ea386ace9f320e1ba59d7eba49b7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ea386ace9f320e1ba59d7eba49b7cf">&#9670;&nbsp;</a></span>get_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; CLI::detail::get_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract default flag values either {def} or starting with a ! </p>

<p class="definition">Definition at line <a class="el" href="Split_8hpp_source.html#l00083">83</a> of file <a class="el" href="Split_8hpp_source.html">Split.hpp</a>.</p>
<div id="dynsection-8" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-8-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a49ea386ace9f320e1ba59d7eba49b7cf_cgraph.svg" width="100%" height="366"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a23ae97bbbd9e400bd94b316dd865cb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ae97bbbd9e400bd94b316dd865cb66">&#9670;&nbsp;</a></span>get_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::vector&lt;std::string&gt;, std::vector&lt;std::string&gt;, std::string&gt; CLI::detail::get_names </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of short names, one of long names, and a single name. </p>

<p class="definition">Definition at line <a class="el" href="Split_8hpp_source.html#l00113">113</a> of file <a class="el" href="Split_8hpp_source.html">Split.hpp</a>.</p>
<div id="dynsection-9" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-9-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-9-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-9-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a23ae97bbbd9e400bd94b316dd865cb66_cgraph.svg" width="100%" height="394"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="ae89da9fa11d234a8bf504d6ec85133cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89da9fa11d234a8bf504d6ec85133cc">&#9670;&nbsp;</a></span>has_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::has_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if the flag definitions has possible false flags </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00275">275</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a42001edb494b249cbb3d10c74c60e404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42001edb494b249cbb3d10c74c60e404">&#9670;&nbsp;</a></span>ini_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::ini_join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a>&#160;</td>
          <td class="paramname"><em>sepChar</em> = <code>','</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a>&#160;</td>
          <td class="paramname"><em>arrayStart</em> = <code>'['</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a>&#160;</td>
          <td class="paramname"><em>arrayEnd</em> = <code>']'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comma separated join, adds quotes if needed. </p>

<p class="definition">Definition at line <a class="el" href="Config_8hpp_source.html#l00069">69</a> of file <a class="el" href="Config_8hpp_source.html">Config.hpp</a>.</p>
<div id="dynsection-10" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-10-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-10-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-10-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a42001edb494b249cbb3d10c74c60e404_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="af6685ecdb07b40a316035bb4af9b02e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6685ecdb07b40a316035bb4af9b02e6">&#9670;&nbsp;</a></span>integral_conversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_unsigned&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::integral_conversion </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to an unsigned integral. </p>
<p>Convert to a signed integral. </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00934">934</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a53b46b96102830769cc02952392e782f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b46b96102830769cc02952392e782f">&#9670;&nbsp;</a></span>is_separator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::is_separator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if a string is a container segment separator (empty or "%%") </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00234">234</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="ac89ce22647a9f697b800d9c47b9d956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89ce22647a9f697b800d9c47b9d956f">&#9670;&nbsp;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::isalpha </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify that str consists of letters only. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00240">240</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a8597debec6c8bc164109538253ffc623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8597debec6c8bc164109538253ffc623">&#9670;&nbsp;</a></span>join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Callable , typename  = typename std::enable_if&lt;!std::is_constructible&lt;std::string, Callable&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function to join a string from processed elements. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00079">79</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="ab351f13ec104e2cba19ec6baf4a552f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab351f13ec104e2cba19ec6baf4a552f6">&#9670;&nbsp;</a></span>join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::join </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function to join a string. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00063">63</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="ab6647281bf64bba7b07737297ae1895d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6647281bf64bba7b07737297ae1895d">&#9670;&nbsp;</a></span>lexical_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AssignTo , typename ConvertTo , enable_if_t&lt; std::is_same&lt; AssignTo, ConvertTo &gt;::value &amp;&amp;(classify_object&lt; AssignTo &gt;::value==object_category::string_assignable||classify_object&lt; AssignTo &gt;::value==object_category::string_constructible), detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::lexical_assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssignTo &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a value through lexical cast operations. </p>
<p>Assign a value from a lexical cast through constructing a value and move assigning it.</p>
<p>Assign a value converted from a string in lexical cast to the output value directly.</p>
<p>Assign a value through lexical cast operations Strings can be empty so we need to do a little different</p>
<p>Assign a value through lexical cast operations for int compatible values mainly for atomic operations on some compilers </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l01234">1234</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>
<div id="dynsection-11" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-11-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-11-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-11-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_ab6647281bf64bba7b07737297ae1895d_cgraph.svg" width="563" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af286727de86fce444325681379e2c511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af286727de86fce444325681379e2c511">&#9670;&nbsp;</a></span>lexical_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::integral_value||classify_object&lt; T &gt;::value==object_category::unsigned_integral, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::lexical_cast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer conversion. </p>
<p>Non-string parsable by a stream.</p>
<p>Non-string convertible from an int.</p>
<p>Assignable from double.</p>
<p>Assignable from int.</p>
<p>Assignable from double or int.</p>
<p>wrapper types</p>
<p>Enumerations.</p>
<p>String and similar constructible and copy assignment.</p>
<p>String and similar direct assignment.</p>
<p>complex</p>
<p>Floats.</p>
<p>Boolean values.</p>
<p>char values </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00998">998</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>
<div id="dynsection-12" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-12-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-12-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-12-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_af286727de86fce444325681379e2c511_cgraph.svg" width="376" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acae078b951ab0e11b84dffe200d0049c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae078b951ab0e11b84dffe200d0049c">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from left of string. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00109">109</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a2cb44de7c57bbb1384f737dc2f04265b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb44de7c57bbb1384f737dc2f04265b">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim anything from left of string. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00118">118</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="ac96583f0b43752f7fa77a6c24dae4802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96583f0b43752f7fa77a6c24dae4802">&#9670;&nbsp;</a></span>overflowCheck() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_signed&lt;T&gt;::value, T&gt;::type CLI::detail::overflowCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a check for overflow on signed numbers. </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00661">661</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>

</div>
</div>
<a id="ad9da7d60b3b5738079257829c777c9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9da7d60b3b5738079257829c777c9c7">&#9670;&nbsp;</a></span>overflowCheck() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_signed&lt;T&gt;::value, T&gt;::type CLI::detail::overflowCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a check for overflow on unsigned numbers. </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00672">672</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>

</div>
</div>
<a id="a73b9afbe8a438ab30291d35f1f24c87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b9afbe8a438ab30291d35f1f24c87c">&#9670;&nbsp;</a></span>remove_default_flag_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CLI::detail::remove_default_flag_values </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00279">279</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a242fa1bec3353c591a730efc6307f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242fa1bec3353c591a730efc6307f3ea">&#9670;&nbsp;</a></span>remove_quotes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::remove_quotes </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove quotes at the front and back of a string either '"' or '\'' </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00161">161</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a5359a7a0e33366a12e15523b100f591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5359a7a0e33366a12e15523b100f591a">&#9670;&nbsp;</a></span>remove_underscore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::remove_underscore </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove underscores from a string </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00256">256</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="af74b520ee1011d38fde77f907ddfea40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74b520ee1011d38fde77f907ddfea40">&#9670;&nbsp;</a></span>rjoin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::rjoin </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a string in reverse order. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00097">97</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="aed9338ae7c45f34f8240a31325d8d71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9338ae7c45f34f8240a31325d8d71c">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from right of string. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00127">127</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a27306fb661edc7a7017a09a0e9ee7b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27306fb661edc7a7017a09a0e9ee7b18">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim anything from right of string. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00136">136</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="aa4b4a0a97c9b07110595765887647385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b4a0a97c9b07110595765887647385">&#9670;&nbsp;</a></span>search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V , enable_if_t&lt;!has_find&lt; T, V &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classV.html">V</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::pair&lt;<a class="el" href="classbool.html">bool</a>, decltype( std::begin( <a class="el" href="namespaceCLI_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>( set ) ) )&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A search function. </p>
<p>A search function that uses the built in find function. </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00615">615</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>
<div id="dynsection-13" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-13-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-13-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-13-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_aa4b4a0a97c9b07110595765887647385_cgraph.svg" width="331" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abcb81a667288aa66a4576a06b9322092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb81a667288aa66a4576a06b9322092">&#9670;&nbsp;</a></span>search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classV.html">V</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classV.html">V</a>(<a class="el" href="classV.html">V</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>filter_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::pair&lt;<a class="el" href="classbool.html">bool</a>, decltype( std::begin( <a class="el" href="namespaceCLI_1_1detail.html#a0c6cf48feae9d909d52e7b4c346cba29">detail::smart_deref</a>( set ) ) )&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A search function with a filter function. </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00639">639</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>
<div id="dynsection-14" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-14-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-14-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-14-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_abcb81a667288aa66a4576a06b9322092_cgraph.svg" width="556" height="136"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adcd67b783a1c4441c89f071774ac398b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd67b783a1c4441c89f071774ac398b">&#9670;&nbsp;</a></span>smart_deref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::remove_reference&lt;T&gt;::type&amp; CLI::detail::smart_deref </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00558">558</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>

</div>
</div>
<a id="a0c6cf48feae9d909d52e7b4c346cba29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6cf48feae9d909d52e7b4c346cba29">&#9670;&nbsp;</a></span>smart_deref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; is_copyable_ptr&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::smart_deref </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype( *value ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l00551">551</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>

</div>
</div>
<a id="a9e78d046d8a9c2d6f246bd1e36e57ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e78d046d8a9c2d6f246bd1e36e57ec6">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a>&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a string by a delim. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00046">46</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a0de15b0ba0d12c9170d15693477808ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de15b0ba0d12c9170d15693477808ed">&#9670;&nbsp;</a></span>split_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::split_long </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Split_8hpp_source.html#l00035">35</a> of file <a class="el" href="Split_8hpp_source.html">Split.hpp</a>.</p>
<div id="dynsection-15" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-15-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-15-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-15-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a0de15b0ba0d12c9170d15693477808ed_cgraph.svg" width="344" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abf817a10b92907070c02b752c37aa09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf817a10b92907070c02b752c37aa09d">&#9670;&nbsp;</a></span>split_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::split_names </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Split_8hpp_source.html#l00070">70</a> of file <a class="el" href="Split_8hpp_source.html">Split.hpp</a>.</p>
<div id="dynsection-16" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-16-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-16-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-16-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_abf817a10b92907070c02b752c37aa09d_cgraph.svg" width="100%" height="366"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a33c9893591d9e9d3d4c9d7282d50b9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c9893591d9e9d3d4c9d7282d50b9d2">&#9670;&nbsp;</a></span>split_program_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::string&gt; CLI::detail::split_program_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>commandline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string into a program name and command line arguments the string is assumed to contain a file name followed by other arguments the return value contains is a pair with the first argument containing the program name and the second everything else. </p>

<p class="definition">Definition at line <a class="el" href="Validators_8hpp_source.html#l01157">1157</a> of file <a class="el" href="Validators_8hpp_source.html">Validators.hpp</a>.</p>
<div id="dynsection-17" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-17-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-17-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-17-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a33c9893591d9e9d3d4c9d7282d50b9d2_cgraph.svg" width="531" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1e6f215bcb727ff49f126ac3e1a13e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6f215bcb727ff49f126ac3e1a13e40">&#9670;&nbsp;</a></span>split_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::split_short </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Split_8hpp_source.html#l00025">25</a> of file <a class="el" href="Split_8hpp_source.html">Split.hpp</a>.</p>
<div id="dynsection-18" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-18-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-18-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-18-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a1e6f215bcb727ff49f126ac3e1a13e40_cgraph.svg" width="308" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aad6e8a6354d9645d3da614f6734573a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6e8a6354d9645d3da614f6734573a8">&#9670;&nbsp;</a></span>split_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; CLI::detail::split_up </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchar.html">char</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'\0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a string '"one two" "three"' into 'one two', 'three' Quote characters can be &lsquo; &rsquo; or " </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00343">343</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>
<div id="dynsection-19" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-19-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-19-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-19-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_aad6e8a6354d9645d3da614f6734573a8_cgraph.svg" width="531" height="130"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aadbd2b5b93afe2f10427dd6e32639b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbd2b5b93afe2f10427dd6e32639b0c">&#9670;&nbsp;</a></span>split_windows_style()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::split_windows_style </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Split_8hpp_source.html#l00053">53</a> of file <a class="el" href="Split_8hpp_source.html">Split.hpp</a>.</p>
<div id="dynsection-20" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-20-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-20-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-20-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_aadbd2b5b93afe2f10427dd6e32639b0c_cgraph.svg" width="311" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af45abf683b881127298aa28b3c4e6cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45abf683b881127298aa28b3c4e6cf5">&#9670;&nbsp;</a></span>to_flag_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t CLI::detail::to_flag_value </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a flag into an integer value typically binary flags. </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00955">955</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>
<div id="dynsection-21" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-21-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-21-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-21-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_af45abf683b881127298aa28b3c4e6cf5_cgraph.svg" width="348" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae83709ec148057ec53df4383645727e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83709ec148057ec53df4383645727e9">&#9670;&nbsp;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::to_lower </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a lower case version of a string. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00246">246</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a4e5965e3013bad7369e985e2f2fd42f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5965e3013bad7369e985e2f2fd42f4">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;!std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a string from the object. </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00345">345</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a9c070858740ce15aaecb1c5f04e21a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c070858740ce15aaecb1c5f04e21a09">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!std::is_convertible&lt; std::string, T &gt;::value &amp;&amp;!std::is_constructible&lt; std::string, T &gt;::value &amp;&amp;is_ostreamable&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>variable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an object to a string (streaming must be supported for that type) </p>
<p>convert a readable container to a string</p>
<p>If conversion is not supported, return an empty string (streaming is not supported for that type) </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00354">354</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a0e94052d485636fc9f18c21009026577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e94052d485636fc9f18c21009026577">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_convertible&lt; T, std::string &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::to_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype( std::forward&lt;T&gt;( value ) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an object to a string (directly forward if this can become a string) </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00336">336</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="ad394fad44bd6c2a82604abba63224a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad394fad44bd6c2a82604abba63224a92">&#9670;&nbsp;</a></span>trim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim whitespace from string. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00145">145</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>
<div id="dynsection-22" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-22-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-22-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-22-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_ad394fad44bd6c2a82604abba63224a92_cgraph.svg" width="308" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a42ffd53b391fe1eebc540f26c8825692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ffd53b391fe1eebc540f26c8825692">&#9670;&nbsp;</a></span>trim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; CLI::detail::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim anything from string. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00150">150</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>
<div id="dynsection-23" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-23-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-23-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-23-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a42ffd53b391fe1eebc540f26c8825692_cgraph.svg" width="308" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5c7b00a328b3b2da564794081646c251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7b00a328b3b2da564794081646c251">&#9670;&nbsp;</a></span>trim_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::trim_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of the string and then trim it. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00155">155</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>
<div id="dynsection-24" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-24-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-24-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-24-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a5c7b00a328b3b2da564794081646c251_cgraph.svg" width="516" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a09bd3735d1104a453e5376a43140d5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bd3735d1104a453e5376a43140d5a8">&#9670;&nbsp;</a></span>trim_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::trim_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a copy of the string and then trim it, any filter string can be used (any char in string is filtered) </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00173">173</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>
<div id="dynsection-25" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-25-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-25-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-25-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a09bd3735d1104a453e5376a43140d5a8_cgraph.svg" width="516" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af643ce5d039d1c94f85ca05591501085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af643ce5d039d1c94f85ca05591501085">&#9670;&nbsp;</a></span>tuple_type_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;I == <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, <a class="el" href="classint.html">int</a>&gt;::type CLI::detail::tuple_type_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>0 if the index &gt; tuple size </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00511">511</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a722986055318f9f83c37749ff14c652f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722986055318f9f83c37749ff14c652f">&#9670;&nbsp;</a></span>type_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt; I&lt;<a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, <a class="el" href="classint.html">int</a>&gt;::type <a class="el" href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>() { return <a class="el" href="structCLI_1_1detail_1_1subtype__count.html">subtype_count</a>&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::value + <a class="el" href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt;T, I + 1&gt;);}template &lt;typename T&gt;struct <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T, typename std::enable_if&lt;<a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="namespaceCLI_1_1detail.html#af643ce5d039d1c94f85ca05591501085">tuple_type_size</a>&lt;T, 0&gt;) };};template &lt;typename T&gt;struct <a class="el" href="structCLI_1_1detail_1_1subtype__count.html">subtype_count</a> { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value ? <a class="el" href="namespaceCLI_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> : <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value };};template &lt;typename T, typename Enable = void&gt;struct type_count_min { static const <a class="el" href="classint.html">int</a> value { 0 };};template &lt;typename T&gt;struct type_count_min&lt; T, typename std::enable_if&lt;!<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value &amp;&amp; !std::is_void&lt;T&gt;::value&gt;::type&gt; { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value };};template &lt;typename T&gt;struct type_count_min&lt;T, typename std::enable_if&lt;<a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr <a class="el" href="classint.html">int</a> value { 1 };};template &lt;typename T&gt;struct type_count_min&lt;T, typename std::enable_if&lt;<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt;typename T::value_type&gt;::value };};template &lt;typename T, std::size_t I&gt;constexpr typename std::enable_if&lt;I == <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, <a class="el" href="classint.html">int</a>&gt;::type tuple_type_size_min() { return 0;}template &lt;typename T, std::size_t I&gt; constexpr typename std::enable_if &lt; I&lt;<a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, <a class="el" href="classint.html">int</a>&gt;::type tuple_type_size_min() { return <a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html">subtype_count_min</a>&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::value + tuple_type_size_min&lt;T, I + 1&gt;);}template &lt;typename T&gt;struct type_count_min&lt;T, typename std::enable_if&lt;<a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr <a class="el" href="classint.html">int</a> value { tuple_type_size_min&lt;T, 0&gt;) };};template &lt;typename T&gt;struct <a class="el" href="structCLI_1_1detail_1_1subtype__count__min.html">subtype_count_min</a> { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value ? ( ( <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value &lt; <a class="el" href="namespaceCLI_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> ) ? <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value : 0 ) : type_count_min&lt;T&gt;::value };};template &lt;typename T, typename Enable = void&gt;struct expected_count { static const <a class="el" href="classint.html">int</a> value { 0 };};template &lt;typename T&gt;struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !std::is_void&lt;T&gt;::value&gt;::type&gt; { static constexpr <a class="el" href="classint.html">int</a> value { 1 };};template &lt;typename T&gt;struct expected_count&lt;T, typename std::enable_if&lt;<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr <a class="el" href="classint.html">int</a> value { <a class="el" href="namespaceCLI_1_1detail.html#a99abe3824b1f1bea457ad0ae635f5c51">expected_max_vector_size</a> };};template &lt;typename T&gt;struct expected_count&lt; T, typename std::enable_if&lt;!<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr <a class="el" href="classint.html">int</a> value { expected_count&lt;typename T::value_type&gt;::value };};enum class object_category : <a class="el" href="classint.html">int</a> { char_value = 1, integral_value = 2, unsigned_integral = 4, enumeration = 6, boolean_value = 8, floating_point = 10, number_constructible = 12, double_constructible = 14, integer_constructible = 16, string_assignable = 23, string_constructible = 24, other = 45, wrapper_value = 50, complex_number = 60, tuple_value = 70, container_value = 80,};template &lt;typename T, typename Enable = void&gt;struct classify_object { static constexpr object_category value { object_category::other };};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, <a class="el" href="classchar.html">char</a>&gt;::value &amp;&amp; std::is_signed&lt;T&gt;::value &amp;&amp; !<a class="el" href="structCLI_1_1is__bool.html">is_bool</a>&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::integral_value };};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; std::is_unsigned&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, <a class="el" href="classchar.html">char</a>&gt;::value &amp;&amp; !<a class="el" href="structCLI_1_1is__bool.html">is_bool</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::unsigned_integral };};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;std::is_same&lt;T, <a class="el" href="classchar.html">char</a>&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::char_value };};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;<a class="el" href="structCLI_1_1is__bool.html">is_bool</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::boolean_value };};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::floating_point };};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; std::is_assignable&lt;T&amp;, std::string&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::string_assignable };};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;!std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_assignable&lt;T&amp;, std::string&gt;::value &amp;&amp; ( <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 ) &amp;&amp; std::is_constructible&lt;T, std::string&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::string_constructible };};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;std::is_enum&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::enumeration };};template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;<a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::complex_number };};template &lt;typename T&gt;struct uncommon_type { using type = typename std::conditional&lt; !std::is_floating_point&lt;T&gt;::value &amp;&amp; !std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_assignable&lt;T&amp;, std::string&gt;::value &amp;&amp; !std::is_constructible&lt;T, std::string&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__complex.html">is_complex</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value, std::true_type, std::false_type&gt;::type; static constexpr <a class="el" href="classbool.html">bool</a> value = type::value;};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;( !<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value &amp;&amp; uncommon_type&lt;T&gt;::value )&gt;::type&gt; { static constexpr object_category value { object_category::wrapper_value };};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 &amp;&amp; !<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, <a class="el" href="classdouble.html">double</a>&gt;::value &amp;&amp; <a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, <a class="el" href="classint.html">int</a>&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::number_constructible };};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 &amp;&amp; !<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, <a class="el" href="classdouble.html">double</a>&gt;::value &amp;&amp; <a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, <a class="el" href="classint.html">int</a>&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::integer_constructible };};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;uncommon_type&lt;T&gt;::value &amp;&amp; <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value == 1 &amp;&amp; !<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, <a class="el" href="classdouble.html">double</a>&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, <a class="el" href="classint.html">int</a>&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::double_constructible };};template &lt;typename T&gt;struct classify_object&lt; T, typename std::enable_if&lt;<a class="el" href="classCLI_1_1detail_1_1is__tuple__like.html">is_tuple_like</a>&lt;T&gt;::value &amp;&amp; ( ( <a class="el" href="structCLI_1_1detail_1_1type__count.html">type_count</a>&lt;T&gt;::value &gt;= 2 &amp;&amp; !<a class="el" href="structCLI_1_1detail_1_1is__wrapper.html">is_wrapper</a>&lt;T&gt;::value ) || ( uncommon_type&lt;T&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, <a class="el" href="classdouble.html">double</a>&gt;::value &amp;&amp; !<a class="el" href="classCLI_1_1detail_1_1is__direct__constructible.html">is_direct_constructible</a>&lt;T, <a class="el" href="classint.html">int</a>&gt;::value ) )&gt;::type&gt; { static constexpr object_category value { object_category::tuple_value }; };template &lt;typename T&gt;struct classify_object&lt;T, typename std::enable_if&lt;<a class="el" href="structCLI_1_1detail_1_1is__mutable__container.html">is_mutable_container</a>&lt;T&gt;::value&gt;::type&gt; { static constexpr object_category value { object_category::container_value };};template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::char_value, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;constexpr const <a class="el" href="classchar.html">char</a>* type_name() { return &quot;CHAR&quot;;}template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::integral_value || classify_object&lt;T&gt;::value == object_category::integer_constructible, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;constexpr const <a class="el" href="classchar.html">char</a>* type_name() { return &quot;INT&quot;;}template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::unsigned_integral, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;constexpr const <a class="el" href="classchar.html">char</a>* type_name() { return &quot;UINT&quot;;}template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::floating_point || classify_object&lt;T&gt;::value == object_category::number_constructible || classify_object&lt;T&gt;::value == object_category::double_constructible, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;constexpr const <a class="el" href="classchar.html">char</a>* type_name() { return &quot;FLOAT&quot;;}template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::enumeration, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;constexpr const <a class="el" href="classchar.html">char</a>* type_name() { return &quot;ENUM&quot;;}template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::boolean_value, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;constexpr const <a class="el" href="classchar.html">char</a>* type_name() { return &quot;BOOLEAN&quot;;}template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::complex_number, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;constexpr const <a class="el" href="classchar.html">char</a>* type_name() { return &quot;COMPLEX&quot;;}template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value &gt;= object_category::string_assignable &amp;&amp; classify_object&lt;T&gt;::value &lt;= object_category::other, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;constexpr const <a class="el" href="classchar.html">char</a>* type_name() { return &quot;TEXT&quot;;}template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value &gt;= 2, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;std::string type_name(); template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::container_value || classify_object&lt;T&gt;::value == object_category::wrapper_value, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;std::string type_name(); template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value == 1, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; = <a class="el" href="namespaceCLI_1_1detail.html#a01c35a876e2917ffdc1ee618e0c06619">detail::dummy</a>&gt;inline std::string type_name() { return type_name&lt;typename std::decay&lt;typename std::tuple_element&lt;0, T&gt;::type&gt;::type&gt;);}template &lt;typename T, std::size_t I&gt;inline typename std::enable_if&lt;I == <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value, std::string&gt;::type tuple_name() { return std::string {};}template &lt;typename T, std::size_t I&gt;inline typename std::enable_if&lt;( I &lt; <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value ), std::string&gt;::type tuple_name() { std::string str = std::string( type_name&lt;typename std::decay&lt;typename std::tuple_element&lt;I, T&gt;::type&gt;::type&gt;) ) + ',' + tuple_name&lt;T, I + 1&gt;); if ( str.back() == ',' ) str.pop_back(); return str;}template &lt;typename T, <a class="el" href="namespaceCLI.html#a17b4ff2556876f1f42e0d585542a1578">enable_if_t</a>&lt;classify_object&lt;T&gt;::value == object_category::tuple_value &amp;&amp; <a class="el" href="structCLI_1_1detail_1_1type__count__base.html">type_count_base</a>&lt;T&gt;::value &gt;= 2, <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">detail::enabler</a>&gt; &gt; std::string CLI::detail::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively generate the tuple type name. </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00915">915</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a397d777acde370a61fdfc1022a97508b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397d777acde370a61fdfc1022a97508b">&#9670;&nbsp;</a></span>type_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; classify_object&lt; T &gt;::value==object_category::container_value||classify_object&lt; T &gt;::value==object_category::wrapper_value, detail::enabler &gt; &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type name for a type that has a value_type member </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00926">926</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a3a05d1129df69e88135e178137b1fd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a05d1129df69e88135e178137b1fd89">&#9670;&nbsp;</a></span>valid_first_char()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::valid_first_char </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the first character of an option. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00215">215</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
<a id="a841371d5dbb0a52f453de4cc1d00cc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841371d5dbb0a52f453de4cc1d00cc51">&#9670;&nbsp;</a></span>valid_later_char()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::valid_later_char </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify following characters of an option. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00221">221</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>
<div id="dynsection-26" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-26-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-26-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-26-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a841371d5dbb0a52f453de4cc1d00cc51_cgraph.svg" width="312" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4274628d24f9e3fbc719284f1db263b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4274628d24f9e3fbc719284f1db263b8">&#9670;&nbsp;</a></span>valid_name_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CLI::detail::valid_name_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify an option name. </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00226">226</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>
<div id="dynsection-27" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-27-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-27-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-27-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a4274628d24f9e3fbc719284f1db263b8_cgraph.svg" width="487" height="82"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9a74f119a795b25c40db74ffa21d3c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a74f119a795b25c40db74ffa21d3c2d">&#9670;&nbsp;</a></span>value_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string CLI::detail::value_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a string as a convertible value for arithmetic types </p>
<p>get a string as a convertible value for enumerations </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00405">405</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>
<div id="dynsection-28" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-28-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-28-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-28-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a9a74f119a795b25c40db74ffa21d3c2d_cgraph.svg" width="342" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a130e048f492ea4619246e2f4cabaf4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130e048f492ea4619246e2f4cabaf4ac">&#9670;&nbsp;</a></span>value_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!std::is_arithmetic&lt; T &gt;::value, detail::enabler &gt;  = detail::dummy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto CLI::detail::value_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype( <a class="el" href="namespaceCLI_1_1detail.html#a0e94052d485636fc9f18c21009026577">to_string</a>( value ) ) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for other types just use the regular to_string function </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00417">417</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>
<div id="dynsection-29" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-29-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-29-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-29-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceCLI_1_1detail_a130e048f492ea4619246e2f4cabaf4ac_cgraph.svg" width="342" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a01c35a876e2917ffdc1ee618e0c06619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c35a876e2917ffdc1ee618e0c06619">&#9670;&nbsp;</a></span>dummy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceCLI_1_1detail.html#af27dda5da343e609526e3dacf435b1c6">enabler</a> CLI::detail::dummy = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An instance to use in EnableIf. </p>

<p class="definition">Definition at line <a class="el" href="TypeTools_8hpp_source.html#l00033">33</a> of file <a class="el" href="TypeTools_8hpp_source.html">TypeTools.hpp</a>.</p>

</div>
</div>
<a id="a99abe3824b1f1bea457ad0ae635f5c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99abe3824b1f1bea457ad0ae635f5c51">&#9670;&nbsp;</a></span>expected_max_vector_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> CLI::detail::expected_max_vector_size { 1 &lt;&lt; 29 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>a constant defining an expected max vector size defined to be a big number that could be multiplied by 4 and not produce overflow for some expected uses </p>

<p class="definition">Definition at line <a class="el" href="StringTools_8hpp_source.html#l00043">43</a> of file <a class="el" href="StringTools_8hpp_source.html">StringTools.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceCLI.html">CLI</a></li><li class="navelem"><a class="el" href="namespaceCLI_1_1detail.html">detail</a></li>
    <li class="footer">Generated on Thu Apr 14 2022 16:52:42 for Radium Engine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
